<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ü§ñ LLM Rover Control</title>
  <style>
    body { font-family: Arial, sans-serif; background:#1a1a1a; color:#fff; padding:20px; margin:0; }
    .container{ max-width:1200px; margin:0 auto; }
    .header{ text-align:center; background:linear-gradient(45deg,#2196F3,#21CBF3); padding:20px; border-radius:10px; margin-bottom:20px;}
    .card{ background:#2a2a2a; padding:20px; border-radius:10px; margin:15px 0; border:1px solid #444;}
    .form-group{ margin:15px 0;}
    label{ display:block; margin-bottom:5px; color:#ccc; font-weight:500;}
    input, textarea{ width:100%; padding:10px; background:#333; border:1px solid #555; border-radius:5px; color:#fff; box-sizing:border-box;}
    textarea{ height:100px; font-family:monospace; resize:vertical;}
    .btn{ padding:12px 20px; background:#2196F3; color:white; border:none; border-radius:5px; cursor:pointer; font-size:16px; margin:5px;}
    .btn:hover{ background:#1976D2;}
    .btn:disabled{ background:#666; cursor:not-allowed;}
    .btn-success{ background:#4caf50;}
    .btn-success:hover{ background:#388e3c;}
    .btn-danger{ background:#f44336;}
    .btn-danger:hover{ background:#d32f2f;}
    .btn-small{ padding:8px 12px; font-size:14px; }
    .output{ background:#1a1a1a; border:1px solid #555; padding:15px; border-radius:5px; height:380px; overflow-y:auto; font-family:monospace; white-space:pre-wrap; font-size:12px;}
    .status{ padding:10px; border-radius:5px; margin:10px 0; display:none;}
    .status.success{ background:#4caf50;}
    .status.error{ background:#f44336;}
    .status.warning{ background:#ff9800; color:#000;}
    .status.info{ background:#2196f3;}
    .tab-buttons{ display:flex; gap:10px; margin-bottom:15px; border-bottom:2px solid #444; padding-bottom:10px; flex-wrap:wrap;}
    .tab-btn{ padding:10px 20px; background:#333; border:none; color:#ccc; cursor:pointer; border-radius:5px 5px 0 0; transition:all .3s;}
    .tab-btn.active{ background:#2196F3; color:white;}
    .tab-content{ display:none;}
    .tab-content.active{ display:block;}
    .preset-commands{ display:flex; flex-wrap:wrap; gap:8px; margin:15px 0;}
    .preset-btn{ padding:8px 12px; background:#444; border:1px solid #666; border-radius:15px; color:#fff; cursor:pointer; font-size:12px;}
    .preset-btn:hover{ background:#555;}
    .image-upload-area{
      border:2px dashed #555; border-radius:8px; padding:25px; text-align:center;
      background:#333; cursor:pointer; transition:all .3s ease;
    }
    .image-upload-area:hover{ border-color:#2196F3; background:#3a3a3a;}
    .image-upload-area.dragover{ border-color:#4caf50; background:#2d4a2d;}
    .image-preview{ max-width:100%; max-height:380px; margin:15px auto; display:none; border-radius:8px; border:1px solid #555;}
    .image-info{ background:#1a1a1a; padding:10px; border-radius:5px; margin:10px 0; font-size:12px; display:none;}
    .analyzed-image-container{ display:none; margin:15px 0; text-align:center;}
    .analyzed-image-container canvas{ max-width:100%; border:2px solid #4caf50; border-radius:8px; background:white;}
    .detection-list{ background:#1a1a1a; padding:15px; border-radius:8px; margin:15px 0; display:none;}
    .detection-item{ padding:8px; margin:5px 0; background:#2a2a2a; border-left:3px solid #4caf50; border-radius:3px;}
    .detection-item.obstacle{ border-left-color:#ff9800;}
    .detection-item.goal{ border-left-color:#f44336;}
    .calibration-info{ background:#2a2a2a; padding:15px; border-radius:8px; border-left:4px solid #ff9800; margin-bottom:20px;}
    .calibration-info h4{ margin-top:0; color:#ff9800;}
    .area-config{ display:grid; grid-template-columns:1fr 1fr; gap:15px; margin:15px 0;}
    .manual-box{ display:none; background:#2a2a2a; padding:15px; border-radius:8px; margin:10px 0; border:2px solid #ff9800;}
    .manual-box h4{ margin:0 0 8px 0; color:#ff9800;}
    .bbox-grid{ display:grid; grid-template-columns:1fr 1fr 1fr 1fr; gap:8px; margin-top:8px;}
    .bbox-grid label{ font-size:12px; }
    .small-note{ font-size:11px; color:#aaa; }
  </style>
</head>

<body>
<div class="container">
  <div class="header">
    <h1>ü§ñ LLM Rover Control</h1>
    <p>AI-Powered Navigation with Image Analysis (Real Bounding Boxes)</p>
  </div>

  <div class="calibration-info">
    <h4>‚öôÔ∏è Key Fixes Applied</h4>
    <p style="margin:5px 0;">
      ‚úÖ AI now returns <b>real bounding boxes</b> (x1,y1,x2,y2%) + confidence.<br/>
      ‚úÖ UI draws boxes accurately (no fixed-size fake boxes).<br/>
      ‚úÖ Manual bbox correction supported if needed.<br/>
      ‚ö†Ô∏è Movement distance still needs feedback (camera re-check / sensors).
    </p>
  </div>

  <div class="card">
    <div class="tab-buttons">
      <button class="tab-btn active" onclick="switchTab(event,'text')">üí¨ Text</button>
      <button class="tab-btn" onclick="switchTab(event,'image')">üñºÔ∏è Image</button>
      <button class="tab-btn" onclick="switchTab(event,'manual')">‚öôÔ∏è Manual</button>
    </div>

    <!-- TEXT TAB -->
    <div id="text-tab" class="tab-content active">
      <h3>üó£Ô∏è Natural Language Control</h3>

      <div class="form-group">
        <label>Tell your rover what to do:</label>
        <textarea id="user-prompt">Move forward for 2 seconds</textarea>
      </div>

      <div class="preset-commands">
        <div class="preset-btn" onclick="setPrompt('move forward for 2 seconds')">Forward 2s</div>
        <div class="preset-btn" onclick="setPrompt('move forward for 5 seconds')">Forward 5s</div>
        <div class="preset-btn" onclick="setPrompt('turn left')">Turn Left</div>
        <div class="preset-btn" onclick="setPrompt('turn right')">Turn Right</div>
        <div class="preset-btn" onclick="setPrompt('move backward for 2 seconds')">Backward 2s</div>
      </div>

      <button class="btn" id="send-command" onclick="sendTextCommand()" style="width:100%;">
        üöÄ Send Command
      </button>
    </div>

    <!-- IMAGE TAB -->
    <div id="image-tab" class="tab-content">
      <h3>üñºÔ∏è Image-Based Navigation</h3>

      <div style="background:#3a2a2a; padding:15px; border-radius:8px; margin-bottom:15px; border-left:4px solid #f44336;">
        <b>Recommended setup for accuracy:</b>
        <ul style="margin:8px 0 0 18px; font-size:13px;">
          <li>Place rover on an <b>A4 paper</b> (draw thick black border on it).</li>
          <li>Make sure the black tape boundary is visible.</li>
          <li>Keep camera angle as top-down as possible.</li>
        </ul>
      </div>

      <div class="form-group">
        <label>üéØ Rover Speed Calibration (meters/second at 100% power)</label>
        <div style="display:flex; gap:10px; align-items:center;">
          <input type="number" id="rover-speed" value="0.3" step="0.05" min="0.05" max="2.0" style="width:110px;">
          <span class="small-note">Example: 0.30 = 30cm per second</span>
        </div>
      </div>

      <div class="form-group">
        <label>Upload Area Map (JPG, JPEG, PNG):</label>
        <div class="image-upload-area" id="dropArea" onclick="document.getElementById('imageInput').click()">
          <p>üì§ Click to upload or drag & drop image here</p>
          <p style="font-size:12px; color:#aaa">Supported: JPG, JPEG, PNG (max 10MB)</p>
        </div>
        <input type="file" id="imageInput" accept="image/jpeg,image/jpg,image/png" style="display:none" onchange="handleImageUpload(event)">

        <img id="imagePreview" class="image-preview" alt="Preview" />

        <div id="imageInfo" class="image-info">
          <b>Image loaded:</b> <span id="imageName"></span><br/>
          <b>Size:</b> <span id="imageSize"></span><br/>
          <b>Dimensions:</b> <span id="imageDimensions"></span><br/>
          <b>Base64 size:</b> <span id="base64Size"></span>
        </div>

        <div id="detectionList" class="detection-list">
          <h4 style="margin:0 0 10px 0; color:#4caf50;">üîç Detected Objects</h4>
          <div id="detectionItems"></div>
        </div>

        <div id="analyzedImageContainer" class="analyzed-image-container">
          <canvas id="analysisCanvas"></canvas>
        </div>
      </div>

      <div class="area-config">
        <div class="form-group">
          <label>Area Width (meters):</label>
          <input type="number" id="areaWidth" value="1.5" step="0.1" min="0.5" max="10">
        </div>
        <div class="form-group">
          <label>Area Height (meters):</label>
          <input type="number" id="areaHeight" value="2.4" step="0.1" min="0.5" max="10">
        </div>
      </div>

      <div class="form-group">
        <label>Navigation Instructions:</label>
        <textarea id="nav-instructions">Navigate from rover position to goal avoiding all obstacles within the black boundary</textarea>
      </div>

      <button class="btn btn-success" id="analyze-image-btn" onclick="analyzeImage()" style="width:100%; margin-bottom:10px;">
        üîç Step 1: Analyze Image & Detect Objects
      </button>

      <!-- Manual bbox correction -->
      <div id="manual-correction" class="manual-box">
        <h4>üìù Manual Bounding Box Correction (Percent)</h4>
        <div class="small-note">Edit bbox % if AI detection is off. x1,y1 is top-left; x2,y2 is bottom-right.</div>

        <div style="margin-top:10px;">
          <b style="color:#00ff00;">ROVER bbox%</b>
          <div class="bbox-grid">
            <div><label>x1%</label><input id="rover-x1" type="number" min="0" max="100"></div>
            <div><label>y1%</label><input id="rover-y1" type="number" min="0" max="100"></div>
            <div><label>x2%</label><input id="rover-x2" type="number" min="0" max="100"></div>
            <div><label>y2%</label><input id="rover-y2" type="number" min="0" max="100"></div>
          </div>
        </div>

        <div style="margin-top:10px;">
          <b style="color:#ff0000;">GOAL bbox%</b>
          <div class="bbox-grid">
            <div><label>x1%</label><input id="goal-x1" type="number" min="0" max="100"></div>
            <div><label>y1%</label><input id="goal-y1" type="number" min="0" max="100"></div>
            <div><label>x2%</label><input id="goal-x2" type="number" min="0" max="100"></div>
            <div><label>y2%</label><input id="goal-y2" type="number" min="0" max="100"></div>
          </div>
        </div>

        <button class="btn btn-small" onclick="applyManualCorrection()" style="width:100%; margin-top:10px;">
          ‚úÖ Apply Corrections & Redraw
        </button>
      </div>

      <button class="btn" id="send-image-command" onclick="sendImageCommand()" style="width:100%;" disabled>
        üó∫Ô∏è Step 2: Generate & Execute Navigation Plan
      </button>
    </div>

    <!-- MANUAL TAB -->
    <div id="manual-tab" class="tab-content">
      <h3>‚öôÔ∏è Manual Controls (Basic)</h3>
      <div class="form-group">
        <label>Duration (seconds):</label>
        <input type="number" id="duration-input" value="2" min="0.2" max="10" step="0.1">
      </div>
      <div class="preset-commands">
        <div class="preset-btn" onclick="quickCommand('forward')">‚Üë Forward</div>
        <div class="preset-btn" onclick="quickCommand('backward')">‚Üì Backward</div>
        <div class="preset-btn" onclick="quickCommand('left')">‚Üê Left</div>
        <div class="preset-btn" onclick="quickCommand('right')">‚Üí Right</div>
        <div class="preset-btn" onclick="quickCommand('stop')">‚èπ Stop</div>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>üîß Settings</h3>
    <div class="form-group">
      <label>Azure Function URL:</label>
      <input type="text" id="function-url" value="https://az-tutorial.azurewebsites.net/api/http_trigger_pi">
      <div class="small-note">Make sure your Function allows CORS or returns Access-Control-Allow-Origin.</div>
    </div>
  </div>

  <div class="card">
    <h3>üìä Response Log</h3>
    <div id="response" class="output">üöÄ Rover Control System Ready

Modes:
‚Ä¢ üí¨ Text: Natural language commands
‚Ä¢ üñºÔ∏è Image: Upload map for AI detection + navigation

Tip:
‚úÖ A4 paper under rover improves repeatability.
</div>

    <div id="status" class="status"></div>

    <button class="btn btn-small" onclick="clearLog()">Clear Log</button>
    <button class="btn btn-danger btn-small" onclick="emergencyStop()">üõë Emergency Stop</button>
  </div>
</div>

<script>
  let commandInProgress = false;
  let uploadedImage = null;
  let uploadedImageElement = null;
  let imageAnalyzed = false;
  let analysisData = null;

  function switchTab(ev, tabName) {
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    ev.target.classList.add('active');

    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.getElementById(tabName + '-tab').classList.add('active');

    addLog(`Switched to ${tabName} mode`, 'info');
  }

  // Drag & Drop setup
  const dropArea = document.getElementById('dropArea');
  ['dragenter','dragover','dragleave','drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, (e) => { e.preventDefault(); e.stopPropagation(); }, false);
  });
  ['dragenter','dragover'].forEach(eventName => {
    dropArea.addEventListener(eventName, () => dropArea.classList.add('dragover'), false);
  });
  ['dragleave','drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, () => dropArea.classList.remove('dragover'), false);
  });
  dropArea.addEventListener('drop', (e) => {
    const files = e.dataTransfer.files;
    if (files.length > 0) handleImageUpload({ target: { files } });
  }, false);

  function handleImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    const validTypes = ['image/jpeg','image/jpg','image/png'];
    if (!validTypes.includes(file.type)) return showStatus('Invalid file type (JPG/PNG only)', 'error');
    if (file.size > 10*1024*1024) return showStatus('File too large (max 10MB)', 'error');

    const reader = new FileReader();
    reader.onload = function(e) {
      uploadedImage = e.target.result;
      imageAnalyzed = false;
      analysisData = null;

      const preview = document.getElementById('imagePreview');
      preview.src = uploadedImage;
      preview.style.display = 'block';
      preview.onload = function() { uploadedImageElement = preview; };

      document.getElementById('imageName').textContent = file.name;
      document.getElementById('imageSize').textContent = (file.size/1024).toFixed(2) + ' KB';
      document.getElementById('base64Size').textContent = (uploadedImage.length/1024).toFixed(2) + ' KB';

      const img = new Image();
      img.onload = function() {
        document.getElementById('imageDimensions').textContent = `${this.width} √ó ${this.height}px`;
      };
      img.src = uploadedImage;

      document.getElementById('imageInfo').style.display = 'block';
      document.getElementById('analyzedImageContainer').style.display = 'none';
      document.getElementById('detectionList').style.display = 'none';
      document.getElementById('send-image-command').disabled = true;
      document.getElementById('manual-correction').style.display = 'none';

      addLog(`‚úÖ Image loaded: ${file.name}`, 'success');
      showStatus('Image uploaded! Click "Analyze Image" first.', 'success');
    };
    reader.readAsDataURL(file);
  }

  function pctToPx(imgW, imgH, p) {
    return { x: (p.x/100)*imgW, y:(p.y/100)*imgH };
  }

  function drawBoxPct(ctx, imgW, imgH, box, strokeStyle, label) {
    const x1 = (box.x1/100)*imgW;
    const y1 = (box.y1/100)*imgH;
    const x2 = (box.x2/100)*imgW;
    const y2 = (box.y2/100)*imgH;
    const w = Math.max(1, x2-x1);
    const h = Math.max(1, y2-y1);

    // translucent fill
    ctx.fillStyle = strokeStyle.replace(')', ',0.18)').replace('rgb','rgba');
    ctx.fillRect(x1, y1, w, h);

    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = 4;
    ctx.strokeRect(x1, y1, w, h);

    ctx.font = 'bold 14px Arial';
    ctx.fillStyle = strokeStyle;
    ctx.fillText(label, x1+6, y1+18);
  }

  function drawBoundary(ctx, imgW, imgH, cornersPct) {
    const pts = cornersPct.map(p => pctToPx(imgW, imgH, p));
    ctx.strokeStyle = '#2196F3';
    ctx.lineWidth = 3;
    ctx.setLineDash([12, 8]);
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#2196F3';
    ctx.font = 'bold 14px Arial';
    ctx.fillText('Boundary', pts[0].x+8, pts[0].y+18);
  }

  function drawA4(ctx, imgW, imgH, cornersPct) {
    const pts = cornersPct.map(p => pctToPx(imgW, imgH, p));
    ctx.strokeStyle = '#9c27b0';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 6]);
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#9c27b0';
    ctx.font = 'bold 14px Arial';
    ctx.fillText('A4 Reference', pts[0].x+8, pts[0].y+18);
  }

  function centerFromBboxPct(b) {
    return { x: (b.x1+b.x2)/2, y: (b.y1+b.y2)/2 };
  }

  function drawAll(analysis) {
    if (!uploadedImageElement) return;

    const canvas = document.getElementById('analysisCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = uploadedImageElement.naturalWidth;
    canvas.height = uploadedImageElement.naturalHeight;
    const imgW = canvas.width, imgH = canvas.height;

    ctx.drawImage(uploadedImageElement, 0, 0);

    if (analysis.boundary && analysis.boundary.found && Array.isArray(analysis.boundary.corners_pct)) {
      drawBoundary(ctx, imgW, imgH, analysis.boundary.corners_pct);
    }
    if (analysis.a4 && analysis.a4.found && Array.isArray(analysis.a4.corners_pct)) {
      drawA4(ctx, imgW, imgH, analysis.a4.corners_pct);
    }

    (analysis.objects || []).forEach(obj => {
      const conf = Math.round((obj.confidence || 0)*100);
      if (obj.label === 'rover') {
        drawBoxPct(ctx, imgW, imgH, obj.bbox_pct, 'rgb(0,255,0)', `ROVER ${conf}%`);
      } else if (obj.label === 'goal') {
        drawBoxPct(ctx, imgW, imgH, obj.bbox_pct, 'rgb(255,0,0)', `GOAL ${conf}%`);
      } else if (obj.label === 'obstacle') {
        drawBoxPct(ctx, imgW, imgH, obj.bbox_pct, 'rgb(255,152,0)', `OBS: ${obj.name}`);
      }
    });

    document.getElementById('analyzedImageContainer').style.display = 'block';
  }

  function displayDetections(analysis) {
    const container = document.getElementById('detectionItems');
    container.innerHTML = '';

    const objs = analysis.objects || [];
    const rover = objs.find(o => o.label==='rover');
    const goal  = objs.find(o => o.label==='goal');
    const obstacles = objs.filter(o => o.label==='obstacle');

    if (rover) {
      const c = centerFromBboxPct(rover.bbox_pct);
      const item = document.createElement('div');
      item.className = 'detection-item';
      item.innerHTML = `<b>ü§ñ Rover</b> | center: (${c.x.toFixed(1)}%, ${c.y.toFixed(1)}%) | conf: ${(rover.confidence*100).toFixed(0)}%`;
      container.appendChild(item);
    }
    if (goal) {
      const c = centerFromBboxPct(goal.bbox_pct);
      const item = document.createElement('div');
      item.className = 'detection-item goal';
      item.innerHTML = `<b>üéØ Goal</b> (${goal.name}) | center: (${c.x.toFixed(1)}%, ${c.y.toFixed(1)}%) | conf: ${(goal.confidence*100).toFixed(0)}%`;
      container.appendChild(item);
    }
    obstacles.forEach(o => {
      const c = centerFromBboxPct(o.bbox_pct);
      const item = document.createElement('div');
      item.className = 'detection-item obstacle';
      item.innerHTML = `<b>‚ö†Ô∏è Obstacle</b> ${o.name} | center: (${c.x.toFixed(1)}%, ${c.y.toFixed(1)}%) | conf: ${(o.confidence*100).toFixed(0)}%`;
      container.appendChild(item);
    });

    document.getElementById('detectionList').style.display = 'block';
  }

  async function analyzeImage() {
    if (!uploadedImage) return showStatus('Upload an image first', 'error');

    const functionUrl = document.getElementById('function-url').value.trim();
    const areaWidth  = parseFloat(document.getElementById('areaWidth').value) || 1.5;
    const areaHeight = parseFloat(document.getElementById('areaHeight').value) || 2.4;

    const analyzeBtn = document.getElementById('analyze-image-btn');
    analyzeBtn.textContent = 'üîÑ Analyzing...';
    analyzeBtn.disabled = true;

    addLog('üîç Starting image analysis (bbox + schema)...', 'info');
    showStatus('Analyzing image...', 'info');

    // Short + clear prompt (schema enforces structure)
    const analysisPrompt =
`Detect rover, goal, obstacles inside the black tape boundary.
Return tight bounding boxes in percent coordinates.
Also detect A4 paper if visible (for distance reference).`;

    try {
      const response = await fetch(functionUrl, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({
          user_prompt: analysisPrompt,
          image: uploadedImage,
          analysis_only: true,
          area_width_m: areaWidth,
          area_height_m: areaHeight
        })
      });

      const data = await response.json();

      if (data.status === 'success' && data.analysis) {
        analysisData = data.analysis;

        addLog('‚úÖ Analysis complete!', 'success');
        addLog(`Notes: ${analysisData.notes || '(none)'}`, 'info');

        displayDetections(analysisData);
        drawAll(analysisData);

        // Populate manual correction for rover & goal
        const rover = (analysisData.objects||[]).find(o=>o.label==='rover');
        const goal  = (analysisData.objects||[]).find(o=>o.label==='goal');
        if (rover && rover.bbox_pct) {
          rover_x1.value = rover.bbox_pct.x1;
          rover_y1.value = rover.bbox_pct.y1;
          rover_x2.value = rover.bbox_pct.x2;
          rover_y2.value = rover.bbox_pct.y2;
        }
        if (goal && goal.bbox_pct) {
          goal_x1.value = goal.bbox_pct.x1;
          goal_y1.value = goal.bbox_pct.y1;
          goal_x2.value = goal.bbox_pct.x2;
          goal_y2.value = goal.bbox_pct.y2;
        }
        document.getElementById('manual-correction').style.display = 'block';

        // Check feasibility
        const hasRover = !!rover;
        const hasGoal  = !!goal;
        imageAnalyzed = hasRover && hasGoal;
        document.getElementById('send-image-command').disabled = !imageAnalyzed;

        if (imageAnalyzed) showStatus('‚úÖ Ready: rover + goal detected.', 'success');
        else showStatus('‚ö†Ô∏è Need rover and goal detected (or manual fix).', 'warning');

      } else {
        addLog(`‚ùå Analysis failed: ${data.error || 'Unknown error'}`, 'error');
        showStatus('Analysis failed. Check log.', 'error');
      }

    } catch (err) {
      addLog(`‚ùå Network error: ${err.message}`, 'error');
      showStatus(`Error: ${err.message}`, 'error');
    } finally {
      analyzeBtn.textContent = 'üîç Step 1: Analyze Image & Detect Objects';
      analyzeBtn.disabled = false;
    }
  }

  function applyManualCorrection() {
    if (!analysisData) return showStatus('No analysis to correct', 'error');

    const rover = (analysisData.objects||[]).find(o=>o.label==='rover');
    const goal  = (analysisData.objects||[]).find(o=>o.label==='goal');

    if (rover) {
      rover.bbox_pct = {
        x1: parseFloat(rover_x1.value), y1: parseFloat(rover_y1.value),
        x2: parseFloat(rover_x2.value), y2: parseFloat(rover_y2.value)
      };
      rover.confidence = Math.max(rover.confidence||0, 0.5); // just keep ok
    }
    if (goal) {
      goal.bbox_pct = {
        x1: parseFloat(goal_x1.value), y1: parseFloat(goal_y1.value),
        x2: parseFloat(goal_x2.value), y2: parseFloat(goal_y2.value)
      };
      goal.confidence = Math.max(goal.confidence||0, 0.5);
    }

    drawAll(analysisData);
    displayDetections(analysisData);

    imageAnalyzed = !!rover && !!goal;
    document.getElementById('send-image-command').disabled = !imageAnalyzed;

    addLog('‚úèÔ∏è Manual bbox correction applied', 'success');
    showStatus('Updated boxes drawn.', 'success');
  }

  async function sendImageCommand() {
    if (!imageAnalyzed || !analysisData) return showStatus('Analyze image first', 'warning');

    const functionUrl = document.getElementById('function-url').value.trim();
    const navInstructions = document.getElementById('nav-instructions').value.trim();
    const roverSpeed = parseFloat(document.getElementById('rover-speed').value) || 0.3;
    const areaWidth  = parseFloat(document.getElementById('areaWidth').value) || 1.5;
    const areaHeight = parseFloat(document.getElementById('areaHeight').value) || 2.4;

    const btn = document.getElementById('send-image-command');
    btn.textContent = 'üîÑ Planning Route...';
    btn.disabled = true;

    // Provide the model the *structured detection result*
    const payloadForPlanner = {
      area: { width_m: areaWidth, height_m: areaHeight },
      rover_speed_mps: roverSpeed,
      detection: analysisData,
      instructions: navInstructions
    };

    addLog('üó∫Ô∏è Sending structured detections to planner...', 'info');

    try {
      const response = await fetch(functionUrl, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({
          user_prompt: "Generate rover movement JSON from the provided detection object and instructions.",
          image: uploadedImage,            // optional, but helps if planner wants to re-check
          planner_payload: payloadForPlanner
        })
      });

      const data = await response.json();

      if (data.status === 'success' && data.generated_json) {
        addLog('‚úÖ Navigation plan generated + sent!', 'success');

        const plan = data.generated_json;
        if (plan.command === 'sequence' && Array.isArray(plan.commands)) {
          let totalDistance = 0;
          plan.commands.forEach((cmd, i) => {
            const movement = cmd.movement || '(turn)';
            const duration = cmd.duration;
            const dist = (duration != null) ? (duration * roverSpeed) : 0;
            totalDistance += dist;
            addLog(`Step ${i+1}: ${movement}${duration!=null ? ` ${duration}s (~${dist.toFixed(2)}m)` : ''}`, 'info');
          });
          addLog(`Total estimated distance: ~${totalDistance.toFixed(2)}m`, 'info');
          addLog(`IoT status: ${data.iot_status}`, data.iot_status === 'sent' ? 'success' : 'warning');
          showStatus('üöÄ Plan sent to rover!', 'success');
        } else {
          addLog('‚ö†Ô∏è Unexpected plan format returned', 'warning');
          showStatus('Plan sent but format unexpected', 'warning');
        }

      } else {
        addLog(`‚ùå Planning failed: ${data.error || 'Unknown error'}`, 'error');
        showStatus('Planning failed. Check log.', 'error');
      }

    } catch (err) {
      addLog(`‚ùå Error: ${err.message}`, 'error');
      showStatus(`Error: ${err.message}`, 'error');
    } finally {
      btn.textContent = 'üó∫Ô∏è Step 2: Generate & Execute Navigation Plan';
      btn.disabled = false;
    }
  }

  async function sendTextCommand() {
    if (commandInProgress) return showStatus('Command in progress, wait...', 'warning');

    const userPrompt = document.getElementById('user-prompt').value.trim();
    const functionUrl = document.getElementById('function-url').value.trim();
    if (!userPrompt) return showStatus('Enter a command', 'error');

    commandInProgress = true;
    const sendButton = document.getElementById('send-command');
    sendButton.textContent = 'üîÑ Sending...';
    sendButton.disabled = true;

    addLog(`Command: "${userPrompt}"`, 'info');
    showStatus('Sending command...', 'info');

    try {
      const response = await fetch(functionUrl, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ user_prompt: userPrompt })
      });

      if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      const data = await response.json();

      if (data.status === 'success') {
        addLog('‚úÖ Command sent!', 'success');
        showStatus('Command sent to rover!', 'success');
      } else {
        addLog(`‚ùå Error: ${data.error}`, 'error');
        showStatus(`Error: ${data.error}`, 'error');
      }
    } catch (err) {
      addLog(`‚ùå Error: ${err.message}`, 'error');
      showStatus(`Error: ${err.message}`, 'error');
    } finally {
      commandInProgress = false;
      sendButton.textContent = 'üöÄ Send Command';
      sendButton.disabled = false;
    }
  }

  function quickCommand(direction) {
    const duration = parseFloat(document.getElementById('duration-input').value) || 2;
    const commands = {
      forward: `move forward for ${duration} seconds`,
      backward: `move backward for ${duration} seconds`,
      left: 'turn left',
      right: 'turn right',
      stop: 'stop all motors'
    };
    setPrompt(commands[direction]);
    sendTextCommand();
  }

  function setPrompt(text){ document.getElementById('user-prompt').value = text; }

  function emergencyStop(){ setPrompt('stop all motors immediately'); sendTextCommand(); }

  function clearLog(){ document.getElementById('response').textContent = 'üöÄ Log cleared.'; }

  function addLog(message, type='info') {
    const output = document.getElementById('response');
    const timestamp = new Date().toLocaleTimeString();
    const icons = { error:'‚ùå', success:'‚úÖ', warning:'‚ö†Ô∏è', info:'üí¨' };
    output.textContent += `\n[${timestamp}] ${icons[type]||'üí¨'} ${message}`;
    output.scrollTop = output.scrollHeight;
  }

  function showStatus(message, type) {
    const status = document.getElementById('status');
    status.textContent = message;
    status.className = `status ${type}`;
    status.style.display = 'block';
    setTimeout(()=> status.style.display='none', 5000);
  }
</script>
</body>
</html>
